<!DOCTYPE html>
<html>
  <head>
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico" />
<link href="../../css/bootstrap/bootstrap.css" rel="stylesheet" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link href="../../css/bootstrap/bootstrap-responsive.css" rel="stylesheet" />
<link rel="stylesheet" type="text/css" href="../../css/swc.css" />
<link rel="stylesheet" type="text/css" href="../../css/swc-bootstrap.css" />
<link rel="alternate" type="application/rss+xml" title="The Software Carpentry Blog" href="/feed.xml"/>
<meta http-equiv="last-modified" content="" />
<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
<!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

  </head>
  <body>
    <div class="container">
      <div class="banner">
  <a href="http://software-carpentry.org" title="Software Carpentry">
    <img alt="Software Carpentry banner" src="../../img/software-carpentry-banner.png" />
  </a>
</div>


      <div class="row-fluid">
        <div class="span10 offset1">
          <h1>Creating a Reproducible Workflow</h1>
          <h2>Introduction</h2>

<p>We&#39;re now in the home stretch of the workshop - congratulations! Up to this 
point, we&#39;ve talked about how to make your code efficient (good programming 
practice), accurate (testing), and maintainable (modularization + version 
control). Now we&#39;re going to talk about a final and very important concept 
known as reproducibility. Victoria Stodden has written extensively about the 
idea of reproducibility in scientific software - you may want to look up <a href="http://www.stanford.edu/%7Evcs/Papers.html">some 
of her papers</a> for reference.</p>

<p>For our purposes, we can summarize the goal of reproducibility in two related 
ways, one technical and one colloquial.</p>

<p>In a technical sense, your goal is to <strong>have a complete chain of custody (ie, 
provenance) from your raw data to your finished results and figures</strong>. That is, 
you should <em>always</em> be able to figure out precisely what data and what code 
were used to generate what result - there should be no &quot;missing links&quot;. If you 
have ever had the experience of coming across a great figure that you made 
months ago and having no idea how in the world you made it, then you understand 
why provenance is important. Or, worse, if you&#39;ve ever been unable to recreate 
the results that you once showed on a poster or (gasp) published in a 
paper...</p>

<p>In a colloquial sense, I should be able to sneak into your lab late at night, 
delete everything except for your raw data and your code, and <strong>you should be 
able to run a single command to regenerate EVERYTHING, including all of your 
results, tables, and figures in their final, polished form</strong>. Think of this as 
the &quot;push button&quot; workflow. This is your ultimate organizational goal as a 
computational scientist. Importantly, note that this rules out the idea of 
manual intervention at any step along the way - no tinkering with figure axes 
in a pop-up window, no deleting columns from tables, no copying data from one 
folder to another, etc. All of that needs to be fully automated.</p>

<p>As an added bonus, if you couple this with a version control system that tracks 
changes over time to your raw data and your code, you will be able to instantly 
recreate your results from any stage in your research (the lab presentation 
version, the dissertation version, the manuscript version, the Nobel Prize 
committee version, etc.). Wouldn&#39;t that be nice?</p>

<p>To illustrate these ideas, we&#39;ll set up a small but realistic research project 
that follows a reproducible workflow. Just like you would in your own research 
projects, we&#39;ll go through the following key steps:</p>

<ol>
<li> Create a clear and useful directory structure for our project.</li>
<li> Set up (and use) Git to track our changes.</li>
<li> Add the raw data to our project.</li>
<li> Write our code to perform the analysis, including tests.</li>
<li> Push the button and watch the magic.</li>
</ol>

<p>One final note - the workflow that we&#39;re following here is just a suggestion. 
Organizing code and data is an art, and a room of 100 scientists will give you 
101 opinions about how to do it best. Consider the below a useful place to get 
started, and don&#39;t hesitate to tinker and branch out as you get a better feel 
for this process. You also might want to review <a href="http://www.ploscompbiol.org/article/info%3Adoi%2F10.1371%2Fjournal.pcbi.1000424">William Noble&#39;s paper</a> on 
this topic for more ideas.</p>

<h2>1.  Setting up the project directory</h2>

<p>Let&#39;s create a project (a reasonably self-contained set of code, data, and 
results to answer a discrete scientific question) that will count the animals 
sighted in two years of camera trap surveys. We begin by creating a directory 
called <code>camera_analysis</code> in a convenient place on our hard drive. You might 
want to create a main directory called <code>Projects</code> or <code>Research</code> in your home 
folder or in your Documents folder to hold the directories for all of your 
individual research projects.</p>

<p>Now, within the <code>camera_analysis</code> directory, create four subdirectories:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">.
├── data
├── man
├── results
├── src
</code></pre></div>
<p>The <code>data</code> directory will hold all of the raw data associated with the project, 
which in this case will be just a single large csv file containing data on the 
animal sightings. The <code>man</code> folder, short for manuscript, will (someday) 
contain the manuscript that we&#39;ll write describing the results of our analysis 
(you were planning on using version control for your manuscript too, weren&#39;t 
you?). The <code>results</code> folder will contain the results of our analysis, including 
both tables and figures, and the <code>src</code> directory will contain all of our code.</p>

<p>In a more complex project, each of these directories may have additional 
subdirectories to help keep things organized.</p>

<p>For bonus points, do this all from the command line.</p>

<h2>2.  Initialize a Git repository</h2>

<p>Since we want to use version control to track the development of our project, 
we&#39;ll start off right away by initializing an empty Git repository within this 
directory. To do this, open a Terminal window, navigate to the main 
<code>camera_analysis</code> directory, and run the command <code>git init</code>.</p>

<p>As you add things to the project directory, and modify old things, you&#39;ll want 
to frequently commit your changes as we discussed in the Git tutorial.</p>

<h2>3.  Add raw data</h2>

<p>Often, we start a project with a particular data file, or set of data files. In 
this case, we have the file <code>sightings_tab_lg.csv</code>, which contains the records 
that we want to analyze. Copy this file from our Github repo into the <code>data</code> 
subdirectory.</p>

<p>Now we reach an interesting question - should your <code>data</code> directory be placed 
under version control (ie, should you <code>git add</code> and <code>git commit</code> these files)? 
Although you might automatically think that this is necessary, in principle our 
raw data should never change - that is, there&#39;s only one version (the original 
version!), and it will never be updated. As a result, it&#39;s not necessarily 
useful to place this file under version control for the purpose of tracking 
changes to it.</p>

<p>A reasonable rule of thumb for getting started is that if the file is 
realatively small (ours is &lt; 100k), go ahead and commit it to the Git 
repository, as you won&#39;t be wasting much hard disk space. Additionally, the 
file will then travel with your code, so if you push your repository to Github 
(for example) and one of your collaborators clones a copy, they&#39;ll have 
everything they need to generate your results.</p>

<p>However, if your file is realatively large AND is backed up elsewhere, you 
might want to avoid making a duplicate copy in the <code>.git</code> directory.</p>

<p>In either case, you&#39;ll want to ensure that every one of your data files has 
some sort of metadata associated with it to describe where it came from, how it 
got to you, the meaning of the columns, etc. There are many formats for 
metadata that vary from simple to very complex. If you&#39;re interested in 
following good ecological best practices, you may want to review the 
<a href="http://knb.ecoinformatics.org/software/eml/">Ecological Metadata Language</a> and the tool <a href="http://knb.ecoinformatics.org/morphoportal.jsp">Morpho</a> for creating 
metadata files. For your own private work, make sure that, at a minimum, you 
create a <code>README.txt</code> file that describes your data as best you can.</p>

<p>Copy and paste the text below into a <code>README.txt</code> file and place it in the data 
subdirectory. Remember that this is a bare-bones description - in your own 
work, you&#39;ll want to include as much information as you have.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Data received via email on April 1, 2013 from Professor Smith. Includes 
records from camera trap surveys conducted by John Doe and Jane Doe from 
2011-2012. Method of collection, site locations, and additional 
descriptions are found in John Doe&#39;s dissertation, Chapter 3 Appendix, 
filed August 2012 at UC Berkeley.
</code></pre></div>
<p>At this point, your project directory should look like this:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">.
├── data
│   ├── README.txt
│   ├── sightings_tab_lg.csv
├── man
├── results
├── src
</code></pre></div>
<p>Add both the data file and readme file to your git repository.</p>

<p>What about the case in which your raw data is hosted elsewhere, on a SQL 
server, for example, or a shared hard drive with your lab? Now your data is 
living somewhere else, and you don&#39;t necessarily have direct control over its 
provenance (what if someone changes it while you weren&#39;t looking?). In this 
situation, you should try to make your <code>runall.py</code> script (see below) make a 
copy of the metadata associated with the dataset (it does have metadata, 
doesn&#39;t it?), which hopefully will include something like a version number and 
a last-updated date, and store this along with your results. That way you&#39;ll at 
least have some information on the version of the data that was used. If 
there&#39;s no metadata, try to shame your collaborators into creating some. If all 
else fails, at least record the date on which your analysis was run so that, in 
principle, you could later try to find out what state the raw data was in on 
that date. If you&#39;re really nervous about the data changing, though, you might 
want to look into making yourself a local copy.</p>

<h2>4. Write code to perform analysis</h2>

<p>Now for the real work - writing the code that will perform our analysis. We&#39;d 
like to generate two outputs. First, we want to make and save a table that 
contains a column with the names of the four mammalian carnivores found in our 
data set - Fox, Wolf, Grizzly, and Wolverine - and a second column that 
contains the total number of records associated with each species. Second, we&#39;d 
like to create and save a simple histogram that shows this result visually.</p>

<h4>Modules and tests</h4>

<p>We&#39;ve already done the work of writing much of this code earlier today, so at 
this point, we can simply copy and paste the file <code>mean_sightings.py</code> from our 
workshop&#39;s git repo into your <code>src</code> subdirectory.</p>

<p>Note, of course, that this is not the normal workflow for this step. Normally, 
you&#39;d spend days/weeks/months working in the <code>src</code> directory, writing code and 
tests, generating results, looking at the results, writing new code and tests, 
generating new results, etc. This iterative cycle isn&#39;t unlike writing a 
paper - you spew out a draft that&#39;s not too bad, then go back and revise it, 
then spew out some new material, revise that, etc.</p>

<p>Different people have different favorite approaches and tools for this 
iterative cycle.</p>

<p>One strategy is to simultaneously work on three files at once - a module like 
<code>mean_sightings.py</code>, a file to test the functions in your module like 
<code>test_mean_sightings.py</code>, and a third script that calls various functions from 
your module and runs them so that you can see whether your code is doing what 
you want it to do. I sometimes call this <code>scratch.py</code> or something like that, 
and fill up my Terminal window with hundreds of lines of <code>python scratch.py</code> as 
I modify my code and look at the results that are saved, results that are 
printed to the Terminal window, and errors that pop up.</p>

<p>Another strategy is to take advantage of the IPython notebook, where you can 
write your code in individual cells and easily execute each one sequentially, 
make sure each cell executes properly, and review the values of variables after 
each step. This can be great and efficient in the event that you really don&#39;t 
have any idea what your final code will look like. The downside here is that, 
at the end, you&#39;ll be left with one enormous notebook file (probably without 
unit tests), and you&#39;ll need to go back at the end to properly modularize your 
code into functions and separate files, similar to the structure that we&#39;re 
using in this exercise, so that you can have a fully reproducible workflow. 
Plus you may end up writing your unit tests at the end (you are going to write 
them, aren&#39;t you?) rather than iteratively with your code as you go. All that 
said, though, this is a great strategy if you think you need to feel your way 
around for a while.</p>

<p>OK, back to our project. We now have the file <code>mean_sightings.py</code> in our <code>src</code> 
directory. Now copy in the file <code>test_mean_sightings.py</code>, which contains our 
unit tests of the functions in <code>mean_sightings.py</code>. You may recall that our 
test functions made use of a small data set, <code>sightings_tab_sm.csv</code>, that we 
created specifically for the purpose of testing our code. It can be a bit 
awkward deciding where to place this csv file - you could potentially put it in 
<code>data</code>, or here in the <code>src</code> directory, or perhaps in a subdirectory of <code>src</code> 
called <code>tests</code> or something like that. This is somewhat a matter of personal 
preference - for now, just copy and paste it here into the <code>src</code> directory 
(even though it&#39;s not technically code). You may want to create a readme file 
for this test data set as well so that you can remember how you created it.</p>

<p>Just to be sure we did everything right, go ahead and run <code>nosetests</code> from the 
Terminal and make sure that your functions still pass. If they don&#39;t for some 
reason, you can try to debug your function or just cheat by copying the file 
<code>mean_sightings-full.py</code> and <code>tes_mean_sightings-full.py</code> from our workshop&#39;s 
git repo into your <code>src</code> directory. Be sure to remove the <code>-full</code> portion of 
the file names and to add a second <code>t</code> to the word <code>test</code> in the second file 
name.</p>

<p>At this point, your project directory should look like this:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">.
├── data
│   ├── README.txt
│   ├── sightings_tab_lg.csv
├── man
├── results
├── src
│   ├── mean_sightings.py
│   ├── sightings_tab_sm.csv
│   ├── test_mean_sightings.py
</code></pre></div>
<p>Add and commit these three new files (your module, test file, and test data 
set) to your git repository. You can commit these together, or separately if 
you think it would be useful to add a different commit message for the 
different files.</p>

<h4>The runall script</h4>

<p>Now that we have our core functions and tests in place, it&#39;s time to create the 
&quot;button&quot; for our push-button workflow - the <code>runall.py</code> script. The idea is 
that you will be able to start with an empty results directory, execute the 
line <code>python runall.py</code> in Terminal, and have our table and figure saved in the 
<code>results</code> directory.</p>

<p>Create a new text file called <code>runall.py</code> and copy and paste the following code 
into it.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">#!/usr/bin/env python

&#39;&#39;&#39;
Script to create all results for camera_analysis project.
&#39;&#39;&#39;

import numpy as np
import matplotlib.mlab as ml
import matplotlib.pyplot as plt
from mean_sightings import get_sightings


# ------------------------------------------------------------------------
# Declare variables
# ------------------------------------------------------------------------

# Set paths to data and results directories. Note that this method of
# relative paths only works on *nix - for Windows, see os.path module.
data_dir = &#39;../data/&#39;
results_dir = &#39;../results/&#39;

# Set name of data file, table, and figure
data_name = &#39;sightings_tab_lg.csv&#39;
table_name = &#39;spp_table.csv&#39;
fig_name = &#39;spp_fig.png&#39;

# Set names of species to count
spp_names = [&#39;Fox&#39;, &#39;Wolf&#39;, &#39;Grizzly&#39;, &#39;Wolverine&#39;]


# ------------------------------------------------------------------------
# Perform analysis 
# ------------------------------------------------------------------------

# Declare empty list to hold counts of records
spp_recs = []

# Get total number of records for each species
for spp in spp_names:
    totalrecs, meancount = get_sightings(data_dir + data_name, spp)
    spp_recs.append(totalrecs)

print spp_names
print spp_recs
</code></pre></div>
<p>We won&#39;t go over this code in too much detail, as you should now have the 
background to understand what&#39;s happening on your own. Right up front, after 
importing the necessary modules, we have set up variables that define the 
locations of the <code>data</code> and <code>results</code> directories (relative to the <code>src</code> 
directory where our <code>runall.py</code> file is located) as well as the names of our 
input data file and the table and figure that we will create. We also declared 
the list of species names here. The purpose of declaring these variables up 
front, rather than just typing these names into the code later on where they 
appear, is to make it easy to change these later on if, for example, we want to 
analyze a different set of species or use a different data file.</p>

<p>After those declarations, we simply set up a <code>for</code> loop that goes through each 
of our species names and uses our previously-written function to get the number 
of records for that species. At the very end, we print out the lists of species 
names and records just to have a look at the output.</p>

<p>Now, go back to your Terminal window, navigate to the <code>src</code> directory, and run 
the command <code>python runall.py</code>. You should see the species names and records 
printed in your Terminal window - this shows that our code is running without 
errors to this point.</p>

<p>Now let&#39;s add some code to save the table. Erase the print lines from the 
bottom of <code>runall.py</code>, and add the text below.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># ------------------------------------------------------------------------
# Save results as table 
# ------------------------------------------------------------------------

# Put two lists into a recarray table
table = np.array(zip(spp_names, spp_recs),
                 dtype=[(&#39;species&#39;, &#39;S12&#39;), (&#39;recs&#39;, int)])

# Save recarray as csv
ml.rec2csv(table, results_dir + table_name)
</code></pre></div>
<p>This code simply takes our two lists, the list of species names and of records, 
and creates a record array from them. The syntax to do this might seem 
confusing, and at this point, it&#39;s probably just best to start by memorizing it 
as the &quot;recipe&quot; that one uses to turn several lists into a record array. The 
<code>dtype</code> variable is used to name each &quot;column&quot; in our recarray and to tell 
Python the format of each column. The first column, called &#39;species&#39;, is given 
the format &#39;S12&#39;, which means a string of up to 12 characters. The second 
column, recs, is given the format int, which stands for an integer. We then use 
a helper function from <code>mlab</code> to save our recarray as a csv file.</p>

<p>Once again, go back to your Terminal window and execute this file. Check to see 
that the csv file was correctly created and saved in the <code>results</code> directory.</p>

<p>Last but not least, let&#39;s add some code to make and save a bar chart that 
visually displays the data that&#39;s in our table. Add the code below to the 
runall file.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># -----------------------------------------------------------------------
# Save results as figure 
# -----------------------------------------------------------------------

# Set up figure with one axis
fig, ax = plt.subplots(1, 1)

# Create bar chart: args are location of left edge, height, and width of bar
ax.bar([0,1,2,3], spp_recs, 0.8)

# Place tick marks in center of each bar
ax.set_xticks([0.4, 1.4, 2.4, 3.4])

# Set limits to give some white space on either side of first/last bar 
ax.set_xlim([-0.2, 4])

# Add species names to x axis
ax.set_xticklabels(spp_names)

# Save figure
fig.savefig(results_dir + fig_name)
</code></pre></div>
<p>This code does just what the comments say that it does. The resulting figure 
looks OK, and you would probably want to spend more time adding additional 
lines here to adjust the formatting.</p>

<p>Don&#39;t forget to add <code>runall.py</code> to your git repo.</p>

<h2>5. Run the push button analysis</h2>

<p>Now with everything in place, we&#39;re ready for the magic. Just for good measure, 
delete any files that are hanging around in your <code>results</code> directory. Then, 
execute <code>python runall.py</code> from your <code>src</code> subdirectory and marvel at your 
fully reproducible workflow! (If you&#39;ve been making a lot of changes to your 
code, and aren&#39;t quite sure what&#39;s in your <code>results</code> directory, you may want to 
periodically clear out this folder and re-run everything to make sure that 
everything is regenerating properly.)</p>

<p>At this point, your directory should look like the below.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">.
├── data
│   ├── README.txt
│   ├── sightings_tab_lg.csv
├── man
├── results
│   ├── spp_table.csv
│   ├── spp_fig.png
├── src
│   ├── mean_sightings.py
│   ├── runall.py
│   ├── sightings_tab_sm.csv
│   ├── test_mean_sightings.py
</code></pre></div>
<p>At this point, a natural question to ask is whether you need to add the 
contents of your <code>results</code> directory to your git repository. The answer should 
be obvious - you do not need to do this, since the files in your <code>results</code> 
directory contain no unique information on their own. Everything you need to 
create them is contained in the <code>data</code> and <code>src</code> directories. One exception to 
this, though, might be if your analysis takes a very long time to run and the 
outputs are fairly small in size, in which case you may want to periodically 
commit (so that you can easily recover) the results associated with 
&quot;intermediate&quot; versions of your code.</p>

<p>While many of your projects will be nearly this simple, some will be more 
complex, sometimes significantly so. You will eventually come across the need 
to deal with modules that are shared across multiple projects, running the same 
analysis on multiple sets of parameters simultaneously, running analyses on 
multiple computers, etc. While we don&#39;t have time to go into these extra bits 
in detail, feel free to ask the instructors about any specific issues that you 
expect to encounter in the near future. Rest assuered that no matter how 
complicated your situation is, Python will provide you with a (relatively) 
efficient and robust way to accomplish your goals. </p>

<p>And that just about does it. Good luck!</p>

	</div>
      </div>

      <div class="footer">
  <a class="label swc-blue-bg" href="https://www.facebook.com/SoftwareCarpentry">Facebook</a>
  <a class="label swc-blue-bg" href="https://plus.google.com/u/0/114244759874490019250/posts">Google+</a>
  <a class="label swc-blue-bg" href="https://twitter.com/swcarpentry">Twitter</a>
  <a class="label swc-blue-bg" href="https://github.com/swcarpentry">GitHub</a>
  <a class="label swc-blue-bg" href="http://software-carpentry.org/feed.xml">RSS</a>
  <a class="label swc-blue-bg" href="../../license.html">License</a>
  <a class="bugreport label swc-blue-bg" href="mailto:info@software-carpentry.org?subject=bug%20in%20lessons/misc-biopython/reproducible_workflow.md">Bug Report</a>
</div>

    </div>
    <!-- Le javascript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="../../js/jquery-1.9.1.min.js"></script>
<script src="../../js/bootstrap/bootstrap.min.js"></script>

  </body>
</html>
